// Autogenerated with StateSmith 0.17.0+31be1fc54adc06a86e0e6ed18288dcac427197fe.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Whatever you put in this `FileTop` section will end up 
// being printed at the top of every generated code file.


// Generated state machine
public partial class NestedNPC
{
    public enum EventId
    {
        BEINGSHOT = 0,
        E3 = 1,
        E4 = 2,
        EONE = 3,
        ETWO = 4,
        FOUNDANOTHERHIDING = 5,
        MORETHAN5SECONDS = 6,
        PLAYERLEFT = 7,
    }

    public const int EventIdCount = 8;

    public enum StateId
    {
        ROOT = 0,
        ATTACK = 1,
        RETREAT = 2,
        SHOOTPLAYER = 3,
        TAKECOVER = 4,
        PATROLLING = 5,
        PATROL = 6,
        PLAYERIDLE = 7,
        WANDER = 8,
    }

    public const int StateIdCount = 9;

    // Used internally by state machine. Feel free to inspect, but don't modify.
    public StateId stateId;

    // State machine variables. Can be used for inputs, outputs, user variables...
    public struct Vars
    {
        public MyTime timer; // this var can be referenced in diagram
        public long count;
    }

    // Variables. Can be used for inputs, outputs, user variables...
    public Vars vars = new Vars();

    // State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
    public NestedNPC()
    {
    }

    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    public void Start()
    {
        ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<InitialState> behavior
            // uml: TransitionTo(Patrolling)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `Patrolling`.
                PATROLLING_enter();

                // Finish transition by calling pseudo state transition function.
                Patrolling_InitialState_transition();
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }

    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    public void DispatchEvent(EventId eventId)
    {
        switch (this.stateId)
        {
            // STATE: NestedNPC
            case StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: Attack
            case StateId.ATTACK:
                switch (eventId)
                {
                    case EventId.PLAYERLEFT: ATTACK_playerleft(); break;
                }
                break;

            // STATE: Retreat
            case StateId.RETREAT:
                switch (eventId)
                {
                    case EventId.FOUNDANOTHERHIDING: RETREAT_foundanotherhiding(); break;
                    case EventId.PLAYERLEFT: ATTACK_playerleft(); break; // First ancestor handler for this event
                }
                break;

            // STATE: ShootPlayer
            case StateId.SHOOTPLAYER:
                switch (eventId)
                {
                    case EventId.MORETHAN5SECONDS: SHOOTPLAYER_morethan5seconds(); break;
                    case EventId.PLAYERLEFT: ATTACK_playerleft(); break; // First ancestor handler for this event
                }
                break;

            // STATE: TakeCover
            case StateId.TAKECOVER:
                switch (eventId)
                {
                    case EventId.E3: TAKECOVER_e3(); break;
                    case EventId.E4: TAKECOVER_e4(); break;
                    case EventId.PLAYERLEFT: ATTACK_playerleft(); break; // First ancestor handler for this event
                }
                break;

            // STATE: Patrolling
            case StateId.PATROLLING:
                switch (eventId)
                {
                    case EventId.BEINGSHOT: PATROLLING_beingshot(); break;
                }
                break;

            // STATE: Patrol
            case StateId.PATROL:
                switch (eventId)
                {
                    case EventId.ETWO: PATROL_etwo(); break;
                    case EventId.BEINGSHOT: PATROLLING_beingshot(); break; // First ancestor handler for this event
                }
                break;

            // STATE: PlayerIdle
            case StateId.PLAYERIDLE:
                switch (eventId)
                {
                    case EventId.ETWO: PLAYERIDLE_etwo(); break;
                    case EventId.EONE: PLAYERIDLE_eone(); break;
                    case EventId.BEINGSHOT: PATROLLING_beingshot(); break; // First ancestor handler for this event
                }
                break;

            // STATE: Wander
            case StateId.WANDER:
                switch (eventId)
                {
                    case EventId.EONE: WANDER_eone(); break;
                    case EventId.ETWO: WANDER_etwo(); break;
                    case EventId.BEINGSHOT: PATROLLING_beingshot(); break; // First ancestor handler for this event
                }
                break;
        }

    }

    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    private void ExitUpToStateHandler(StateId desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case StateId.ATTACK: ATTACK_exit(); break;

                case StateId.RETREAT: RETREAT_exit(); break;

                case StateId.SHOOTPLAYER: SHOOTPLAYER_exit(); break;

                case StateId.TAKECOVER: TAKECOVER_exit(); break;

                case StateId.PATROLLING: PATROLLING_exit(); break;

                case StateId.PATROL: PATROL_exit(); break;

                case StateId.PLAYERIDLE: PLAYERIDLE_exit(); break;

                case StateId.WANDER: WANDER_exit(); break;

                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////

    private void ROOT_enter()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ATTACK
    ////////////////////////////////////////////////////////////////////////////////

    private void ATTACK_enter()
    {
        this.stateId = StateId.ATTACK;
    }

    private void ATTACK_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void ATTACK_playerleft()
    {
        // Attack behavior
        // uml: PlayerLeft TransitionTo(Patrolling)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Patrolling`.
            PATROLLING_enter();

            // Finish transition by calling pseudo state transition function.
            Patrolling_InitialState_transition();
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for Attack

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RETREAT
    ////////////////////////////////////////////////////////////////////////////////

    private void RETREAT_enter()
    {
        this.stateId = StateId.RETREAT;
    }

    private void RETREAT_exit()
    {
        this.stateId = StateId.ATTACK;
    }

    private void RETREAT_foundanotherhiding()
    {
        // Retreat behavior
        // uml: FoundAnotherHiding TransitionTo(TakeCover)
        {
            // Step 1: Exit states until we reach `Attack` state (Least Common Ancestor for transition).
            RETREAT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `TakeCover`.
            TAKECOVER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Retreat

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state SHOOTPLAYER
    ////////////////////////////////////////////////////////////////////////////////

    private void SHOOTPLAYER_enter()
    {
        this.stateId = StateId.SHOOTPLAYER;
    }

    private void SHOOTPLAYER_exit()
    {
        this.stateId = StateId.ATTACK;
    }

    private void SHOOTPLAYER_morethan5seconds()
    {
        // ShootPlayer behavior
        // uml: MoreThan5Seconds TransitionTo(TakeCover)
        {
            // Step 1: Exit states until we reach `Attack` state (Least Common Ancestor for transition).
            SHOOTPLAYER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `TakeCover`.
            TAKECOVER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ShootPlayer

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TAKECOVER
    ////////////////////////////////////////////////////////////////////////////////

    private void TAKECOVER_enter()
    {
        this.stateId = StateId.TAKECOVER;
    }

    private void TAKECOVER_exit()
    {
        this.stateId = StateId.ATTACK;
    }

    private void TAKECOVER_e3()
    {
        // TakeCover behavior
        // uml: E3 TransitionTo(ShootPlayer)
        {
            // Step 1: Exit states until we reach `Attack` state (Least Common Ancestor for transition).
            TAKECOVER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ShootPlayer`.
            SHOOTPLAYER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TakeCover

        // No ancestor handles this event.
    }

    private void TAKECOVER_e4()
    {
        // TakeCover behavior
        // uml: E4 TransitionTo(Retreat)
        {
            // Step 1: Exit states until we reach `Attack` state (Least Common Ancestor for transition).
            TAKECOVER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Retreat`.
            RETREAT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TakeCover

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PATROLLING
    ////////////////////////////////////////////////////////////////////////////////

    private void PATROLLING_enter()
    {
        this.stateId = StateId.PATROLLING;
    }

    private void PATROLLING_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void PATROLLING_beingshot()
    {
        // Patrolling behavior
        // uml: BeingShot TransitionTo(TakeCover)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `TakeCover`.
            ATTACK_enter();
            TAKECOVER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Patrolling

        // No ancestor handles this event.
    }

    private void Patrolling_InitialState_transition()
    {
        // Patrolling.<InitialState> behavior
        // uml: TransitionTo(PlayerIdle)
        {
            // Step 1: Exit states until we reach `Patrolling` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PlayerIdle`.
            PLAYERIDLE_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Patrolling.<InitialState>
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PATROL
    ////////////////////////////////////////////////////////////////////////////////

    private void PATROL_enter()
    {
        this.stateId = StateId.PATROL;
    }

    private void PATROL_exit()
    {
        this.stateId = StateId.PATROLLING;
    }

    private void PATROL_etwo()
    {
        // Patrol behavior
        // uml: ETwo TransitionTo(Wander)
        {
            // Step 1: Exit states until we reach `Patrolling` state (Least Common Ancestor for transition).
            PATROL_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Wander`.
            WANDER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Patrol

        // unreachable behavior: `ETwo TransitionTo(PlayerIdle)` due to unconditional transition above

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYERIDLE
    ////////////////////////////////////////////////////////////////////////////////

    private void PLAYERIDLE_enter()
    {
        this.stateId = StateId.PLAYERIDLE;
    }

    private void PLAYERIDLE_exit()
    {
        this.stateId = StateId.PATROLLING;
    }

    private void PLAYERIDLE_eone()
    {
        // PlayerIdle behavior
        // uml: EOne TransitionTo(Patrol)
        {
            // Step 1: Exit states until we reach `Patrolling` state (Least Common Ancestor for transition).
            PLAYERIDLE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Patrol`.
            PATROL_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PlayerIdle

        // No ancestor handles this event.
    }

    private void PLAYERIDLE_etwo()
    {
        // PlayerIdle behavior
        // uml: ETwo TransitionTo(Wander)
        {
            // Step 1: Exit states until we reach `Patrolling` state (Least Common Ancestor for transition).
            PLAYERIDLE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Wander`.
            WANDER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PlayerIdle

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WANDER
    ////////////////////////////////////////////////////////////////////////////////

    private void WANDER_enter()
    {
        this.stateId = StateId.WANDER;
    }

    private void WANDER_exit()
    {
        this.stateId = StateId.PATROLLING;
    }

    private void WANDER_eone()
    {
        // Wander behavior
        // uml: EOne TransitionTo(Patrol)
        {
            // Step 1: Exit states until we reach `Patrolling` state (Least Common Ancestor for transition).
            WANDER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `Patrol`.
            PATROL_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Wander

        // No ancestor handles this event.
    }

    private void WANDER_etwo()
    {
        // Wander behavior
        // uml: ETwo TransitionTo(PlayerIdle)
        {
            // Step 1: Exit states until we reach `Patrolling` state (Least Common Ancestor for transition).
            WANDER_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PlayerIdle`.
            PLAYERIDLE_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Wander

        // No ancestor handles this event.
    }

    // Thread safe.
    public static string StateIdToString(StateId id)
    {
        switch (id)
        {
            case StateId.ROOT: return "ROOT";
            case StateId.ATTACK: return "ATTACK";
            case StateId.RETREAT: return "RETREAT";
            case StateId.SHOOTPLAYER: return "SHOOTPLAYER";
            case StateId.TAKECOVER: return "TAKECOVER";
            case StateId.PATROLLING: return "PATROLLING";
            case StateId.PATROL: return "PATROL";
            case StateId.PLAYERIDLE: return "PLAYERIDLE";
            case StateId.WANDER: return "WANDER";
            default: return "?";
        }
    }

    // Thread safe.
    public static string EventIdToString(EventId id)
    {
        switch (id)
        {
            case EventId.BEINGSHOT: return "BEINGSHOT";
            case EventId.E3: return "E3";
            case EventId.E4: return "E4";
            case EventId.EONE: return "EONE";
            case EventId.ETWO: return "ETWO";
            case EventId.FOUNDANOTHERHIDING: return "FOUNDANOTHERHIDING";
            case EventId.MORETHAN5SECONDS: return "MORETHAN5SECONDS";
            case EventId.PLAYERLEFT: return "PLAYERLEFT";
            default: return "?";
        }
    }
}
